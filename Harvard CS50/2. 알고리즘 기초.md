# Topic1: 입력한 자료를 출력하려면 어떤 과정이 필요할까?

## 핵심 단어

- 알고리즘
- 정확성
- 효율성

## 수업 내용

### 1. 알고리즘

- 입력값을 출력값의 형태로 바꾸기 위해 어떤 명령들이 수행되어야 하는지에 대한 규칙들이 순서적 나열
- 순서적 규칙들의 나열 방법에 따라 알고리즘의 종류가 달라짐

### 2. 정확한 알고리즘(정확성)

전화번호부에서 Mike Smith를 찾는 일을 한다고 할 때, 전화번호부의 첫 페이지에서부터 마지막 페이지까지 한 장씩 넘기며 Mike Smith를 찾는 알고리즘은 정확하다.
하지만, 효율적인 알고리즘이라고 할 수는 없다.

### 3. 효율적인 알고리즘(효율성)

전화번호부 가운데를 편 후, Mike Smith가 그 페이지에 있다면 알고리즘은 끝나게 된다. 하지만 없다면, 전화번호부가 이름순으로 정렬되어 있기 때문에 Mike Smith가 현재 페이지보다 앞쪽에 있을지 뒤쪽에 있을지 예측할 수 있다. 이러한 방법으로 책의 절반을 계속해서 버리는 식으로 알고리즘을 수행하게 되면 훨씬 더 빠르게 Mike Smith를 찾을 수 있다.
이 알고리즘은 기존 알고리즘보다 더 효율적이다. 

<br />

# Topic2: 알고리즘을 이해하기 쉽게 표현하는 방법이 있을까?
## 핵심 단어

- 프로그래밍 언어
- 의사 코드
- 할당
- 들여쓰기

## 수업 내용

### 1. 의사 코드

프로그래밍 언어보다 문법적 제약을 적게 받으므로 알고리즘 표현에 많이 사용됨

### 2. 의사 코드의 요소

- 할당: 값을 할당한다.
- 반복문: 어떤 조건 하에서 특정 명령문이 반복되어 실행된다.
- 조건문: 특정 조건으로 명령이 실행되기도 하고 건너뛰어지기도 한다.

→ 의사 코드는 문법 걱정 없이 알고리즘을 단계별로 표현할 수 있는 유용한 방법으로, 프로그램의 논리를 이해하는 데 효과적이다.

<br />

# Topic3: 자료를 맨 처음부터 하나씩 비교하면서 찾는 방법은 무엇이라고 할까?
## 핵심 단어

- 선형 탐색

## 수업 내용

### 1. 선형 탐색

원하는 원소가 발견될 때까지 처음부터 마지막 자료까지 차례대로 탐색

### 2. 효율성 그리고 비효율성

- 선형 탐색 알고리즘은 정확하지만 매우 효율적이지 못한 방법
- 리스트의 길이: n, 최악의 경우는 리스트의 모든 원소를 확인해야 하므로 n번만큼 실행됨
- 선형 탐색은 자료가 정렬되어 있지 않거나 그 어떤 정보도 없이 하나씩 찾아야 하는 경우에 유용 → 탐색 이전에 **정렬**을 해주는 것이 중요한 이유
    - 정렬은 시간이 오래 걸리고 공간을 더 차지
    - but, 정렬이라는 추가적인 과정을 진행하면 여러 번 리스트 검색해야 하거나 매우 큰 리스트를 검색해야 할 때 시간 단축 가능

### 3. 선형 탐색의 예시

전화번호부 예시: Mike라는 이름을 찾기 위해 전화번호부를 한 장, 한 장 훑어보는 것

<br />

# Topic4: 인접한 두 개의 자료를 차례로 비교하면서 정렬하는 것을 무엇이라고 할까?

인접한 두 개의 자료가 차례차례 비교되면서 위치를 찾아가는 모습이 거품이 보글보글 일어나는 것처럼 보인다고 하여 버블 정렬이라고 부른다.

## 핵심 단어

- 버블 정렬
- 배열

## 수업 내용

### 1. 버블 정렬

- 두 개의 인접한 자료 값을 비교하면서 위치를 교환하는 방식으로 정렬
- 단 두 개의 요소만 정렬해주는 좁은 범위의 정렬에 집중
- 해당 접근법은 간단하지만 단 하나의 요소를 정렬하기 위해 너무 많이 교환하는 낭비가 발생할 수 있음

### 2. 실행
<img width="369" alt="1 (1)" src="https://user-images.githubusercontent.com/53208493/102205232-41257d00-3f0e-11eb-9f92-eff902500ae9.png">   

- 첫번째 실행 시: **n-1번 비교**
- 두번째 실행 시: **n-2번 비교** 
- 마지막 실행 시: **1번 비교**
- 비교 횟수: **(n-1) + (n-2) + ... + 1 = n(n-1)/2**
    - **n<sup>2</sup>/2 - n/2**
    - n값이 커질수록 비교 횟수는 매우 많아진다는 것을 의미
    - 여기서 n/2는 매우 작은 숫자라 신경 쓰지 않아도 된다고 생각하자   
    ---> **따라서 버블 정렬은 O(n<sup>2</sup>)와 Ω(n)의 실행시간을 갖는다.** (뒤에서 더 자세하게 살펴볼 내용)

### 3. 정렬된 배열
- 수행 한 번 만에 모든 원소가 정렬되는 것을 보장하지 않음
- 예를 들어 6, 5, 4, 3, 2, 1과 같이 거꾸로 정렬된 경우 다섯 번 시도해야 함
- 즉, n개의 요소를 정렬해주기 위해서는 n-1번 실행해주어야 하므로 경제적이지 않음

<br />

# Topic5: 자료 중 가장 작은 것을 찾아 순서대로 정렬하는 방법은 무엇일까?

## 핵심 단어

- 선택 정렬
- 배열

## 수업 내용

### 1. 선택 정렬

- 배열 안의 자료 중 가장 작은 수(혹은 가장 큰 수)를 찾아 첫 번째 위치(혹은 가장 마지막 위치)의 수와 교환해주는 방식의 정렬
- 교환 횟수를 최소화하는 반면 각 자료를 비교하는 횟수는 증가함

### 2. 실행
<img width="367" alt="선택 정렬" src="https://user-images.githubusercontent.com/53208493/102358738-35f84d00-3ff3-11eb-8544-dfcfd1bdec56.PNG">  

- 첫번째 실행 시: **n-1번 비교**
- 두번째 실행 시: **n-2번 비교**
- 마지막 번째 실행 시: **1번 비교**
- 비교 횟수: **(n-1) + (n-2) + ... + 1 = n(n-1)/2**
    - **n<sup>2</sup>/2 - n/2**
    - 선택 정렬은 계속해서 작은 값을 찾으려고 하므로 하한 시간 또한 n<sup>2</sup>이다.   
    ---> **따라서 선택 정렬은 O(n<sup>2</sup>)와 Ω(n<sup>2</sup>)의 실행시간을 갖는다.**

### 3. 정렬된 배열

- 원래 배열의 순서와 상관없이, 선택 정렬로 정렬되는 배열은 n-1번의 교환이 필요
- 한 번의 교환이 일어나기 위해서는 정렬되지 않은 수의 모든 비교가 이루어져야 하므로, n<sup>2</sup>번의 비교가 이루어진다.

<br />

# Topic6: 정렬된 부분, 정렬되지 않은 부분을 나누어 정렬하는 방법은 무엇일까?

## 핵심 단어

- 삽입 정렬
- 배열

## 수업 내용

### 1. 삽입 정렬

- 자료를 여러 번 비교하거나 교환할 필요가 없는 방법
- 삽입 정렬은 자료가 정렬된 부분과 정렬되지 않은 부분으로 나누어짐
- 정렬되지 않은 부분의 자료가 정렬된 부분의 자리로 삽입되는 형태의 정렬 방법

### 2. 실행
<img width="367" alt="1 (2)" src="https://user-images.githubusercontent.com/53208493/102357870-288e9300-3ff2-11eb-8e89-9b576ebf8325.png">  

- 첫번째 실행 시: **n-1번 움직임**
- 두번째 실행 시: **n-2번 움직임**
- 마지막 번째 실행 시: **1번 움직임**
- 비교 횟수: **(n-1) + (n-2) + ... + 1 = n(n-1)/2**
    - **n<sup>2</sup>/2 - n/2**   
    ---> **따라서 선택 정렬은 O(n<sup>2</sup>)의 실행시간을 갖는다.**

### 3. 정렬된 배열

- 특정 실행 단계에서, 어떤 원소가 정렬된 배열 내에 자리를 찾았다고 해서 그것이 최종적인 제자리라는 보장이 없다.
    - 다음 단계가 진행되면 다른 자료에 의해 위치가 바뀔 수 있기 때문
- 삽입 정렬은 자료의 양이 적을 때 성능이 우수하며 자료 대부분이 이미 정렬되어있는 경우에 효율적이다.

<br />

# Topic7: 정렬 알고리즘의 효율성을 높이기 위해서는 무엇을 고려해야 할까?
정렬 알고리즘을 수행할 때 소요되는 시간을 기준으로 정렬 알고리즘의 효율성을 분석하자. 
정렬 알고리즘을 빠르게 수행하기 위해서는 비교와 교환 등을 처리하는 횟수가 적어야 한다.

## 핵심 단어

- 시간 복잡도
- Big-O 표기법
- Big Ω(omega)

## 수업 내용

### 1. 시간 복잡도

- 알고리즘 수행 시 걸리는 시간을 기준으로 효율성을 분석하는 것
- 시간의 효율성: 알고리즘에서 비교와 교환 등이 일어날 때 **연산자의 처리 횟수가 적다**는 의미 → 시간의 복잡도가 낮다는 의미

### 2. Big-O 표기법

컴퓨터 과학에서 "대략"을 나타내는 공식적인 개념으로, 최악의 경우에 대한 시간 복잡도를 나타내는 표현

- **선형 탐색**
    - **찾는 값이 배열의 맨 끝에 있는 최악의 상황**: 원하는 값을 찾는데 n번의 단계를 거치면 됨
    - **O(n)**
- **버블 정렬**
    - 인접해 있는 자료와 쌍을 이루어 비교하므로, **n개의 자료를 갖는 배열은 n-1쌍을 비교**
    - 전체 비교 횟수: **n(n-1)/2**
    - **O(n<sup>2</sup>)**
- **선택 정렬**
    - 가장 작은 값을 찾아 제 자리를 찾아주므로, **n개의 자료가 있다면 첫번째 자료와 나머지 n-1개의 자료 중 가장 작은 값의 자리를 교환**
    - 전체 비교 횟수: **n(n-1)/2**
    - **O(n<sup>2</sup>)**
- **삽입 정렬**
    - **n개의 자료가 있다면 첫번째 자료는 정렬되었다고 생각하고, n-1개의 자료 중 첫번째 자료와 정렬된 자료를 비교**
    - 정렬된 자료는 1개이기 때문에 비교 횟수는 1이다
    정렬되지 않은 부분에 1개의 자료가 남게 되면, 정렬된 자료의 수 n-1개 만큼의 비교가 필요하다. 따라서 비교 횟수는 **1 + 2 + … + (n-1)**
    - 전체 비교 횟수: **n(n-1)/2**
    - **O(n<sup>2</sup>)**

<img width="295" alt="good" src="https://user-images.githubusercontent.com/53208493/102501712-14fe2d80-40c1-11eb-8f99-c2195d50a0da.PNG">

### 3. Big Ω 표기법

최선의 경우를 나타낸다.

- **선형 탐색**  
    배열의 처음에 찾고자 하는 값이 있는 상황, 이는 배열의 크기와 상관없이 **Ω(1)** 이라고 나타냄
- **버블 정렬**  
    교환이 이루어지지 않더라도 배열이 정렬된 사실을 모르기 때문에 여전히 **n-1번의 비교** 를 해줘야 한다. 그래서 최선의 경우는 **Ω(n)** 로 표기
- **선택 정렬**  
    역시 배열이 정렬되었다는 것을 알 수 없어, 최소값을 계속 찾아주어야 하므로 **Ω(n<sup>2</sup>)** 로 표기
- **삽입 정렬**  
    정렬되지 않은 부분에서 정렬된 부분으로 옮겨갈 때, 정렬된 부분의 가장 큰 수와 비교하기만 하면 되기 때문에 **Ω(n)** 로 표기

<br />

# Topic8: 많은 자료를 분해하고 다시 합쳐 정렬하는 것을 무엇이라고 할까?
많은 양의 데이터가 한 개가 될 때까지 반으로 분해하고 또 분해한다. 그리고 다시 그 데이터를 합치고 합치는 것을 합병 정렬이라고 한다.

## 핵심 단어
- 합병 정렬
- 분할 정복

## 수업 내용

### 1. 합병 정렬

원소가 한 개가 될 때까지 계속해서 반으로 나누다가 다시 합쳐나가며 정렬을 하는 방식

### 2. 실행
![KakaoTalk_20201216_115204285 (2)](https://user-images.githubusercontent.com/53208493/102714919-4d964500-4315-11eb-9f6b-002848ae8da9.jpg)
1. 이 프로그램이 시작되면 6개의 원소를 가진 배열은 반으로 나뉘고, 원소가 1개가 될 때까지 계속해서 나누어지게 된다.
2. step4와 같이 모든 원소가 1개가 됐을 때, 다시 합쳐지면서 정렬이 이루어지게 된다.
3. step4에서 5로 넘어가면서 3과 5의 크기를 비교하고 정렬된 채로 넘어가는 것과 같이, 나머지 나누어진 부분도 같은 방식으로 병합된다.

→ step4를 중심으로 나누어지고(step2, step3) 합쳐지는 과정(step5, step6)이 역순으로 이루어져 있다는 것을 알 수 있다.  
→ 이렇게 나누어지고 합쳐지는 중간 단계의 배열을 임시로 저장하고 함수가 종료될 때까지 기억하고 있어야 하므로, 메모리가 필요한 공간이 늘어난다.

### 3. 정렬된 배열
- 만약 8개의 원소가 있다면 합병 정렬에서는 3번 나누어질 것이다. 따라서, **n개의 원소가 있을 때 완전히 다 나누어지기까지 호출되는 함수의 개수는 log n개이다.**  
- 합쳐지는 과정에서는 **각 원소들의 크기를 비교하기 때문의 n번의 비교 과정**이 있다. 즉, 한번 나누어질 때마다 n번의 비교 횟수가 추가되는 것이므로 **합병 정렬의 시간 복잡도는 O(n log n)** 이다.

<br />

# Topic9: 정렬된 데이터에서 원하는 값을 쉽고 빠르게 찾는 방법은 무엇일까?

## 핵심 단어
- 이진 탐색
- 중간값

## 수업 내용
### 1. 이진 탐색
자료를 절반으로 나눈 후 찾는 값이 어느 쪽에 있는지 파악해 탐색의 범위를 반으로 줄여나가는 탐색 알고리즘

### 2. 효율성과 비효율성
배열을 정렬하는 데는 다양한 방법이 있다. 이러한 정렬 방법은 **이진 탐색을 구현하는 데 유용**하다.  
이진 탐색의 기본은 **정렬된 배열**을 만들 수 있다는 데 가정을 두고 있다.

<img width="308" alt="1" src="https://user-images.githubusercontent.com/53208493/102714894-217ac400-4315-11eb-910c-09b17a97f4f3.PNG">

위 그림은 이진 탐색의 실행 과정을 보여주고 있다.

### 3. 이진 탐색 vs 선형 탐색
- 이진 탐색
    - 배열을 여러 번 탐색할 계획을 하고 있다면, 이진 탐색이 유용
    - 찾고자 하는 값이 배열에 없는 경우 또한 이진 탐색이 효율적
- 선형 탐색
    - 이진 탐색과 달리 배열을 정렬하는 시간이 필요하지 않음
    - 배열이 정렬되어있지 않은 경우, 이진 탐색보다 선형 탐색이 더 효율적일 수 있음
