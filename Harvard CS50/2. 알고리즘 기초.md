# Topic1: 입력한 자료를 출력하려면 어떤 과정이 필요할까?

## 핵심 단어

- 알고리즘
- 정확성
- 효율성

## 수업 내용

### 1. 알고리즘

- 입력값을 출력값의 형태로 바꾸기 위해 어떤 명령들이 수행되어야 하는지에 대한 규칙들이 순서적 나열
- 순서적 규칙들의 나열 방법에 따라 알고리즘의 종류가 달라짐

### 2. 정확한 알고리즘(정확성)

전화번호부에서 Mike Smith를 찾는 일을 한다고 할 때, 전화번호부의 첫 페이지에서부터 마지막 페이지까지 한 장씩 넘기며 Mike Smith를 찾는 알고리즘은 정확하다.
하지만, 효율적인 알고리즘이라고 할 수는 없다.

### 3. 효율적인 알고리즘(효율성)

전화번호부 가운데를 편 후, Mike Smith가 그 페이지에 있다면 알고리즘은 끝나게 된다. 하지만 없다면, 전화번호부가 이름순으로 정렬되어 있기 때문에 Mike Smith가 현재 페이지보다 앞쪽에 있을지 뒤쪽에 있을지 예측할 수 있다. 이러한 방법으로 책의 절반을 계속해서 버리는 식으로 알고리즘을 수행하게 되면 훨씬 더 빠르게 Mike Smith를 찾을 수 있다.
이 알고리즘은 기존 알고리즘보다 더 효율적이다. 

</br>

# Topic2: 알고리즘을 이해하기 쉽게 표현하는 방법이 있을까?
## 핵심 단어

- 프로그래밍 언어
- 의사 코드
- 할당
- 들여쓰기

## 수업 내용

### 1. 의사 코드

프로그래밍 언어보다 문법적 제약을 적게 받으므로 알고리즘 표현에 많이 사용됨

### 2. 의사 코드의 요소

- 할당: 값을 할당한다.
- 반복문: 어떤 조건 하에서 특정 명령문이 반복되어 실행된다.
- 조건문: 특정 조건으로 명령이 실행되기도 하고 건너뛰어지기도 한다.

→ 의사 코드는 문법 걱정 없이 알고리즘을 단계별로 표현할 수 있는 유용한 방법으로, 프로그램의 논리를 이해하는 데 효과적이다.

</br>

# Topic3: 자료를 맨 처음부터 하나씩 비교하면서 찾는 방법은 무엇이라고 할까?
## 핵심 단어

- 선형 탐색

## 수업 내용

### 1. 선형 탐색

원하는 원소가 발견될 때까지 처음부터 마지막 자료까지 차례대로 탐색

### 2. 효율성 그리고 비효율성

- 선형 탐색 알고리즘은 정확하지만 매우 효율적이지 못한 방법
- 리스트의 길이: n, 최악의 경우는 리스트의 모든 원소를 확인해야 하므로 n번만큼 실행됨
- 선형 탐색은 자료가 정렬되어 있지 않거나 그 어떤 정보도 없이 하나씩 찾아야 하는 경우에 유용 → 탐색 이전에 **정렬**을 해주는 것이 중요한 이유
    - 정렬은 시간이 오래 걸리고 공간을 더 차지
    - but, 정렬이라는 추가적인 과정을 진행하면 여러 번 리스트 검색해야 하거나 매우 큰 리스트를 검색해야 할 때 시간 단축 가능

### 3. 선형 탐색의 예시

전화번호부 예시: Mike라는 이름을 찾기 위해 전화번호부를 한 장, 한 장 훑어보는 것

</br>

# Topic4: 인접한 두 개의 자료를 차례로 비교하면서 정렬하는 것을 무엇이라고 할까?

인접한 두 개의 자료가 차례차례 비교되면서 위치를 찾아가는 모습이 거품이 보글보글 일어나는 것처럼 보인다고 하여 버블 정렬이라고 부른다.

## 핵심 단어

- 버블 정렬
- 배열

## 수업 내용

### 1. 버블 정렬

- 두 개의 인접한 자료 값을 비교하면서 위치를 교환하는 방식으로 정렬
- 단 두 개의 요소만 정렬해주는 좁은 범위의 정렬에 집중
- 해당 접근법은 간단하지만 단 하나의 요소를 정렬하기 위해 너무 많이 교환하는 낭비가 발생할 수 있음

### 2. 실행
<img width="369" alt="1 (1)" src="https://user-images.githubusercontent.com/53208493/102205232-41257d00-3f0e-11eb-9f92-eff902500ae9.png">   

- 첫번째 실행 시: **n-1번 비교**
- 두번째 실행 시: **n-2번 비교** 
- 마지막 실행 시: **1번 비교**
- 비교 횟수: **(n-1) + (n-2) + ... + 1 = n(n-1)/2**
    - **n<sup>2</sup>/2 - n/2**
    - n값이 커질수록 비교 횟수는 매우 많아진다는 것을 의미
    - 여기서 n/2는 매우 작은 숫자라 신경 쓰지 않아도 된다고 생각하자   
    ---> **따라서 버블 정렬은 O(n<sup>2</sup>)와 Ω(n)의 실행시간을 갖는다.** (뒤에서 더 자세하게 살펴볼 내용)

### 3. 정렬된 배열
- 수행 한 번 만에 모든 원소가 정렬되는 것을 보장하지 않음
- 예를 들어 6, 5, 4, 3, 2, 1과 같이 거꾸로 정렬된 경우 다섯 번 시도해야 함
- 즉, n개의 요소를 정렬해주기 위해서는 n-1번 실행해주어야 하므로 경제적이지 않음

</br>

# Topic5: 자료 중 가장 작은 것을 찾아 순서대로 정렬하는 방법은 무엇일까?

## 핵심 단어

- 선택 정렬
- 배열

## 수업 내용

### 1. 선택 정렬

- 배열 안의 자료 중 가장 작은 수(혹은 가장 큰 수)를 찾아 첫 번째 위치(혹은 가장 마지막 위치)의 수와 교환해주는 방식의 정렬
- 교환 횟수를 최소화하는 반면 각 자료를 비교하는 횟수는 증가함

### 2. 실행
<img width="367" alt="선택 정렬" src="https://user-images.githubusercontent.com/53208493/102358738-35f84d00-3ff3-11eb-8544-dfcfd1bdec56.PNG">  

- 첫번째 실행 시: **n-1번 비교**
- 두번째 실행 시: **n-2번 비교**
- 마지막 번째 실행 시: **1번 비교**
- 비교 횟수: **(n-1) + (n-2) + ... + 1 = n(n-1)/2**
    - **n<sup>2</sup>/2 - n/2**
    - 선택 정렬은 계속해서 작은 값을 찾으려고 하므로 하한 시간 또한 n<sup>2</sup>이다.   
    ---> **따라서 선택 정렬은 O(n<sup>2</sup>)와 Ω(n<sup>2</sup>)의 실행시간을 갖는다.**

### 3. 정렬된 배열

- 원래 배열의 순서와 상관없이, 선택 정렬로 정렬되는 배열은 n-1번의 교환이 필요
- 한 번의 교환이 일어나기 위해서는 정렬되지 않은 수의 모든 비교가 이루어져야 하므로, n<sup>2</sup>번의 비교가 이루어진다.

</br>

# Topic6: 정렬된 부분, 정렬되지 않은 부분을 나누어 정렬하는 방법은 무엇일까?

## 핵심 단어

- 삽입 정렬
- 배열

## 수업 내용

### 1. 삽입 정렬

- 자료를 여러 번 비교하거나 교환할 필요가 없는 방법
- 삽입 정렬은 자료가 정렬된 부분과 정렬되지 않은 부분으로 나누어짐
- 정렬되지 않은 부분의 자료가 정렬된 부분의 자리로 삽입되는 형태의 정렬 방법

### 2. 실행
<img width="367" alt="1 (2)" src="https://user-images.githubusercontent.com/53208493/102357870-288e9300-3ff2-11eb-8e89-9b576ebf8325.png">  

- 첫번째 실행 시: **n-1번 움직임**
- 두번째 실행 시: **n-2번 움직임**
- 마지막 번째 실행 시: **1번 움직임**
- 비교 횟수: **(n-1) + (n-2) + ... + 1 = n(n-1)/2**
    - **n<sup>2</sup>/2 - n/2**   
    ---> **따라서 선택 정렬은 O(n<sup>2</sup>)의 실행시간을 갖는다.**

### 3. 정렬된 배열

- 특정 실행 단계에서, 어떤 원소가 정렬된 배열 내에 자리를 찾았다고 해서 그것이 최종적인 제자리라는 보장이 없다.
    - 다음 단계가 진행되면 다른 자료에 의해 위치가 바뀔 수 있기 때문
- 삽입 정렬은 자료의 양이 적을 때 성능이 우수하며 자료 대부분이 이미 정렬되어있는 경우에 효율적이다.
